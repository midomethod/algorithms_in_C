// Filename: stackrecursion.cpp
//
// The file basically contains two functions that generate all subsequences of an input string. One function is the (standard) recursive method,
// while the other is non-recursive and uses a stack. Both these functions have an identical output, and create a (linked) list of strings as their output.
// 
// The code uses the List data structure used in a number of CSE101 assignments and tests.
// 
// USAGE:  (the executable is generated by a Makefile)
//     ./stackrecursion <INPUT FILE> <OUTPUT FILE>
// 
//     Only the first line of <INPUT FILE> is read, as a string. <OUTPUT FILE> contains all subsequences, each in a separate line.
// 
// 
// C. Seshadhri, Jan 2020

#include <iostream>
#include "list.h"
#include <stack>
#include <stdexcept>
#include <fstream>
#include <array>
#include <vector> 
#include <algorithm>
#include <sstream>
using namespace std;


// This class keeps pairs of string. This is useful for simulating the recursion through as stack.
class Pair
{
    public:
        string in_str;
        string fixed_str;
};

class Word
{
	public:
		string word;
		int count;
};

// allAnagram
//	All permutations of the input string with length L
List allAnagram(string input_str)
{
	List final_output;

	stack<class Pair> recurStack; // empty stack that performs the recursion
    Pair init, stacktop; // create a pair to push, to start the stack
    init.in_str = input_str; // put the initial string
    init.fixed_str = ""; // this is the fixed string, initially empty
    string searchStr;
    string modiStr;
    recurStack.push(init); // push this pair onto the top

    while(!recurStack.empty()) // while the stack is non-empty
    {
        stacktop = recurStack.top();// get the top pair in stack 
        //cout << "in_str:\t\t" << stacktop.in_str << endl;
        //cout << "fixed_str:\t" << stacktop.fixed_str << endl;
        recurStack.pop(); // remove the top element of stack
        //cout << "CP1: In the while loop"<< endl;
        if (stacktop.fixed_str.length() == input_str.length()) // input string is empty, so this is base case
        {
            final_output.insert(stacktop.fixed_str); // insert the fixed string onto list
            //cout<<"CP2: Fixed = Length, Inserting..."<<stacktop.fixed_str<<endl;
            //cout << "Inserting to Final Output..." << stacktop.fixed_str << endl;
            //cout << final_output.print("\n") << endl << endl;
            continue; // pop the next element of stack
        }
        // get last element of in_str
        //cout << "Last:\t\t" << last << endl;
        searchStr = stacktop.in_str;
        
        //cout<<"CP3: Fixed != Length,"<<endl;

        int i = 0;
        while(searchStr.length()!=0)
        {
        	modiStr = stacktop.in_str;
        	//cout<<"CP4: Traversing... i = "<< to_string(i) <<endl;
        	char top = searchStr.front();
        	searchStr=searchStr.erase(0,1);
        	//cout<<"\tPasses the first erase: searchStr = "<<searchStr<<endl;
        	//cout<<"\t\ttop = "<<top<<endl;
        	Pair to_push;
        	if(i!=0)
        	{
        		to_push.in_str = modiStr.erase(i,i);
        	}
        	else
        	{
        		to_push.in_str = modiStr.erase(0,1);
        	}
        	//cout<<"\tPasses the second erase: to_push.in_str = "<<to_push.in_str<<endl;
        	to_push.fixed_str = top + stacktop.fixed_str; 
        	recurStack.push(to_push);
        	i++;
        }
    }
	return final_output;
}
// language
// 	All permutation of the chars of from length 0 up to length k 
List language(string input_str, int k)
{
	List final_output; // generate empty list
    stack<class Word> recurStack; // empty stack that performs the recursion
    Word init, stacktop,to_push; // create a pair to push, to start the stack
    init.word = ""; // put the initial string
    init.count = input_str.length(); // this is the fixed string, initially empty
    recurStack.push(init); // push this pair onto the top
	
    while(!recurStack.empty())
    {
    	stacktop = recurStack.top();
    	recurStack.pop();

    	if(stacktop.count<=stacktop.word.length())
    	{
    			if(stacktop.count==stacktop.word.length())
    			{
    				if(final_output.find(stacktop.word)!=NULL)
    				{
    					final_output.insert(stacktop.word);
    				}
    			}
    			continue;
    	}


    	for(int i = 0; i<input_str.length();i++)
    	{
    		to_push.word=stacktop.word+input_str[i];
    		to_push.count=stacktop.count;
    		recurStack.push(to_push);
    	}
    	for(int i = 0; i<input_str.length();i++)
    	{
    		to_push.word=stacktop.word+input_str[i];
    		to_push.count=stacktop.count-1;
    		recurStack.push(to_push);
    	}
    	to_push.word=stacktop.word;
    	to_push.count=stacktop.count-1;
    	recurStack.push(to_push);
    }
    return final_output;
}
// stretch
// 	Make strings that retain the original order but may repeat the same character from 1-k times in order
List stretch(string input_str, int z)
{
	List final_output;
	stack<class Pair> recurStack;
	Pair init, topush, stacktop;
	init.in_str=input_str;
	init.fixed_str="";
	string dummy = input_str;

	recurStack.push(init);

	while(!recurStack.empty())
	{
		stacktop=recurStack.top();
		recurStack.pop();

		if(stacktop.in_str.length()==0)
		{
			final_output.insert(stacktop.fixed_str);
		}

		char top = stacktop.in_str.front();

		topush.in_str=stacktop.in_str.erase(0,1);
		for(int i=0;i<z;i++)
		{
				topush.fixed_str=top+stacktop.fixed_str;
				recurStack.push(topush);
		}
	}


	return final_output;
}



// This function generates all subsequences of the input input_str, and outputs them as a list. This function does not use recursion.
// Input: string input_str
// Output: list of all subsequences of input_str
// 
List allSubSeqStack(string input_str)
{
    List final_output; // generate empty list
    stack<class Pair> recurStack; // empty stack that performs the recursion
    Pair init, stacktop; // create a pair to push, to start the stack
    init.in_str = input_str; // put the initial string
    init.fixed_str = ""; // this is the fixed string, initially empty
    recurStack.push(init); // push this pair onto the top

    while(!recurStack.empty()) // while the stack is non-empty
    {
        stacktop = recurStack.top();// get the top pair in stack 
        cout << "in_str:\t\t" << stacktop.in_str << endl;
        cout << "fixed_str:\t" << stacktop.fixed_str << endl;
        recurStack.pop(); // remove the top element of stack
        if (stacktop.in_str.length() == 0) // input string is empty, so this is base case
        {
            final_output.insert(stacktop.fixed_str); // insert the fixed string onto list
          //  cout << "Inserting to Final Output..." << stacktop.fixed_str << endl;
            //cout << final_output.print("\n") << endl << endl;
            continue; // pop the next element of stack
        }
        char last = stacktop.in_str.back(); // get last element of in_str
        //cout << "Last:\t\t" << last << endl;
        stacktop.in_str.pop_back(); // remove last element of stack
        Pair to_push; // setting up elements to push onto stack
        to_push.in_str = stacktop.in_str;
        to_push.fixed_str = stacktop.fixed_str; 
        //cout << "to_push:\t" << to_push.in_str << "\t" << to_push.fixed_str << endl;
        recurStack.push(to_push); // this is for one recursive call
        to_push.fixed_str = last + stacktop.fixed_str; // this is for next recursive call
        //cout << "to_push:\t" << to_push.in_str << "\t" << to_push.fixed_str << endl;
        recurStack.push(to_push);
        //cout << endl;
    }
    return final_output;
}

// This recursive function generates all subsequences of the input in_str *appended* to the fixed_str, and outputs them in the list provided as an argument
// Input: string fixed_str, string in_str, pointer to list list_ptr
// Output: void, but list referenced by list_ptr is modified
// 



void allSubSeqRec(string in_str, string fixed_str, List *list_ptr)
{
    if (in_str.length() == 0) // base case
    {
        list_ptr->insert(fixed_str); // insert the fixed string into list
        return;
    }
    char top = in_str.back(); // get the last element of the string
    in_str.pop_back(); // delete last element of in_str
    allSubSeqRec(in_str, fixed_str, list_ptr); // recursive call for subsequences without top
    allSubSeqRec(in_str, top+fixed_str, list_ptr); //  recursive call for subsequences with top
    return;
}

// This function generates all subsequences of the input in_str, and outputs them as a list. This is the recursive version
// Input: string in_str
// Output: list of all subsequences of in_str
// 
List allSubSeq(string in_str)
{
    List *final_output = new List(); // generate empty list
    allSubSeqRec(in_str,"",final_output); // populate list with output
    return *final_output;
}


int main(int argc, char** argv)
{
    if (argc < 3) // must provide two arguments as input
    {
        throw std::invalid_argument("Usage: ./hello <INPUT FILE> <OUTPUT FILE>"); // throw error
    }

    ifstream input; // stream for input file
    ofstream output; // stream for output file

    input.open(argv[1]); // open input file
    output.open(argv[2]); // open output file

    string in_str; // to store the input string from the file


    getline(input, in_str); // get the single string from the input file
    
    List myList = stretch(in_str,2); // initializing the linked list

    myList.sort(); // sort the list
    
    output << myList.print("\n") << endl;  // print the list, using a new line as delimiter between items of the list
    
    myList.deleteList(); // free all the memory of this list

    input.close();
    output.close();
}
 